// File: catboard.v
// Generated by MyHDL 1.0dev
// Date: Mon Apr  9 10:36:50 2018


`timescale 1ns/10ps

module catboard (
    clock,
    led,
    uart_tx,
    uart_rx
);
// The LEDs are controlled from the RPi over the UART
// to the FPGA.

input clock;
output [3:0] led;
reg [3:0] led;
output uart_tx;
wire uart_tx;
input uart_rx;

reg [7:0] ledreg;
reg [27:0] memmap_mem_addr;
reg [7:0] tone;
reg glbl_tick_sec;
reg [31:0] memmap_read_data;
reg [31:0] memmap_write_data;
reg memmap_done;
reg memmap_write;
reg memmap_read;
wire glbl_timer_ticks0_reset;
reg [16:0] glbl_timer_ticks0_mscnt;
reg [9:0] glbl_timer_ticks0_seccnt;
reg glbl_timer_ticks0_timer_counter0_overflow;
wire [7:0] uartlite0_fbusrx_read_data;
reg uartlite0_fifobus_write;
wire uartlite0_fbusrx_read;
reg uartlite0_fbusrx_empty;
wire uartlite0_fifobus_empty;
reg uartlite0_baudce16;
reg uartlite0_tx;
wire uartlite0_fifobus_read_valid;
wire uartlite0_rx;
reg uartlite0_baudce;
reg uartlite0_fbustx_full;
reg uartlite0_fifobus_read;
reg [7:0] uartlite0_fifobus_write_data;
wire uartlite0_fbusrx_read_valid;
wire uartlite0_fifobus_full;
wire [7:0] uartlite0_fbustx_write_data;
wire [7:0] uartlite0_fifobus_read_data;
wire uartlite0_fbustx_write;
reg [14:0] uartlite0_uartbaud0_cnt;
reg [3:0] uartlite0_uartbaud0_cnt16;
reg uartlite0_uartrx0_midbit;
reg [7:0] uartlite0_uartrx0_rxbyte;
reg uartlite0_uartrx0_rxinprog;
reg uartlite0_uartrx0_rxd;
reg [7:0] uartlite0_uartrx0_fbusrx_write_data;
reg [1:0] uartlite0_uartrx0_state;
reg [3:0] uartlite0_uartrx0_mcnt;
reg [3:0] uartlite0_uartrx0_bitcnt;
reg uartlite0_uartrx0_fbusrx_write;
reg [7:0] uartlite0_uarttx0_txbyte;
reg uartlite0_uarttx0_fbustx_empty;
reg uartlite0_uarttx0_fbustx_read;
reg [3:0] uartlite0_uarttx0_bitcnt;
reg [2:0] uartlite0_uarttx0_state;
wire [7:0] uartlite0_uarttx0_fbustx_read_data;
reg [2:0] uartlite0_fifo_fast0_nvacant;
reg [2:0] uartlite0_fifo_fast0_ntenant;
reg [1:0] uartlite0_fifo_fast0_addr;
wire uartlite0_fifo_fast0_fbus_clear;
wire uartlite0_fifo_fast0_fbus_read_valid;
reg [2:0] uartlite0_fifo_fast1_nvacant;
reg [2:0] uartlite0_fifo_fast1_ntenant;
reg [1:0] uartlite0_fifo_fast1_addr;
reg uartlite0_fifo_fast1_fbus_full;
wire uartlite0_fifo_fast1_fbus_clear;
reg command_bridge0_ready;
reg [3:0] command_bridge0_state;
reg [7:0] command_bridge0_bytemon;
wire [31:0] command_bridge0_address;
wire [31:0] command_bridge0_data;
reg [3:0] command_bridge0_bb_per_addr;
reg command_bridge0_error;
reg [5:0] command_bridge0_controller_basic0_tocnt;
reg [2:0] command_bridge0_controller_basic0_state;
reg uartlite0_syncro0_staps [0:3-1];
reg [7:0] uartlite0_fifo_fast0_mem [0:4-1];
reg uartlite0_syncro1_staps [0:3-1];
reg [7:0] uartlite0_fifo_fast1_mem [0:4-1];
reg [7:0] command_bridge0_packet [0:12-1];

assign glbl_timer_ticks0_reset = 1'd0;
assign uartlite0_fifo_fast0_fbus_clear = 1'd0;
assign uartlite0_fifo_fast1_fbus_clear = 1'd0;
assign command_bridge0_address[32-1:24] = command_bridge0_packet[2];
assign command_bridge0_address[24-1:16] = command_bridge0_packet[3];
assign command_bridge0_address[16-1:8] = command_bridge0_packet[4];
assign command_bridge0_address[8-1:0] = command_bridge0_packet[5];
assign command_bridge0_data[32-1:24] = command_bridge0_packet[8];
assign command_bridge0_data[24-1:16] = command_bridge0_packet[9];
assign command_bridge0_data[16-1:8] = command_bridge0_packet[10];
assign command_bridge0_data[8-1:0] = command_bridge0_packet[11];


always @(posedge clock) begin: CATBOARD_GLBL_TIMER_TICKS0_TIMER_COUNTER0_BEH_COUNT
    if (glbl_timer_ticks0_reset == 1) begin
        glbl_timer_ticks0_mscnt <= 0;
    end
    else begin
        if (1'b1) begin
            if (($signed({1'b0, glbl_timer_ticks0_mscnt}) == (100000 - 1))) begin
                glbl_timer_ticks0_mscnt <= 0;
            end
            else begin
                glbl_timer_ticks0_mscnt <= (glbl_timer_ticks0_mscnt + 1);
            end
        end
    end
end


always @(posedge clock) begin: CATBOARD_GLBL_TIMER_TICKS0_TIMER_COUNTER0_BEH_OVERFLOW
    if ((1'b1 && ($signed({1'b0, glbl_timer_ticks0_mscnt}) == (100000 - 2)))) begin
        glbl_timer_ticks0_timer_counter0_overflow <= 1'b1;
    end
    else begin
        glbl_timer_ticks0_timer_counter0_overflow <= 1'b0;
    end
end


always @(posedge clock) begin: CATBOARD_GLBL_TIMER_TICKS0_TIMER_COUNTER1_BEH_COUNT
    if (glbl_timer_ticks0_reset == 1) begin
        glbl_timer_ticks0_seccnt <= 0;
    end
    else begin
        if (glbl_timer_ticks0_timer_counter0_overflow) begin
            if (($signed({1'b0, glbl_timer_ticks0_seccnt}) == (1000 - 1))) begin
                glbl_timer_ticks0_seccnt <= 0;
            end
            else begin
                glbl_timer_ticks0_seccnt <= (glbl_timer_ticks0_seccnt + 1);
            end
        end
    end
end


always @(posedge clock) begin: CATBOARD_GLBL_TIMER_TICKS0_TIMER_COUNTER1_BEH_OVERFLOW
    if ((glbl_timer_ticks0_timer_counter0_overflow && ($signed({1'b0, glbl_timer_ticks0_seccnt}) == (1000 - 2)))) begin
        glbl_tick_sec <= 1'b1;
    end
    else begin
        glbl_tick_sec <= 1'b0;
    end
end



assign uartlite0_rx = uartlite0_syncro0_staps[(3 - 1)];


always @(posedge clock) begin: CATBOARD_UARTLITE0_SYNCRO0_BEH_SYNC_STAGES
    integer ii;
    uartlite0_syncro0_staps[0] <= uart_rx;
    for (ii=1; ii<3; ii=ii+1) begin
        uartlite0_syncro0_staps[ii] <= uartlite0_syncro0_staps[(ii - 1)];
    end
end


always @(posedge clock) begin: CATBOARD_UARTLITE0_UARTBAUD0_BEH_BAUD
    if (glbl_timer_ticks0_reset == 1) begin
        uartlite0_uartbaud0_cnt16 <= 0;
        uartlite0_baudce <= 0;
    end
    else begin
        if (uartlite0_baudce16) begin
            uartlite0_uartbaud0_cnt16 <= (uartlite0_uartbaud0_cnt16 + 1);
            if ((uartlite0_uartbaud0_cnt16 == 0)) begin
                uartlite0_baudce <= 1'b1;
            end
            else begin
                uartlite0_baudce <= 1'b0;
            end
        end
        else begin
            uartlite0_baudce <= 1'b0;
        end
    end
end


always @(posedge clock) begin: CATBOARD_UARTLITE0_UARTBAUD0_BEH_BAUD16
    if (glbl_timer_ticks0_reset == 1) begin
        uartlite0_uartbaud0_cnt <= 0;
        uartlite0_baudce16 <= 0;
    end
    else begin
        if ((uartlite0_uartbaud0_cnt >= 15337)) begin
            uartlite0_uartbaud0_cnt <= (uartlite0_uartbaud0_cnt - 15337);
            uartlite0_baudce16 <= 1'b1;
        end
        else begin
            uartlite0_uartbaud0_cnt <= (uartlite0_uartbaud0_cnt + 288);
            uartlite0_baudce16 <= 1'b0;
        end
    end
end


always @(posedge clock) begin: CATBOARD_UARTLITE0_UARTRX0_BEH_RX
    if (glbl_timer_ticks0_reset == 1) begin
        uartlite0_uartrx0_bitcnt <= 0;
        uartlite0_uartrx0_fbusrx_write_data <= 0;
        uartlite0_uartrx0_state <= 2'b00;
        uartlite0_uartrx0_rxbyte <= 0;
        uartlite0_uartrx0_fbusrx_write <= 0;
    end
    else begin
        uartlite0_uartrx0_fbusrx_write <= 1'b0;
        case (uartlite0_uartrx0_state)
            2'b00: begin
                if ((uartlite0_uartrx0_midbit && (!uartlite0_rx))) begin
                    uartlite0_uartrx0_state <= 2'b01;
                end
            end
            2'b01: begin
                if (uartlite0_uartrx0_midbit) begin
                    uartlite0_uartrx0_rxbyte[uartlite0_uartrx0_bitcnt] <= uartlite0_rx;
                    uartlite0_uartrx0_bitcnt <= (uartlite0_uartrx0_bitcnt + 1);
                end
                else if ((uartlite0_uartrx0_bitcnt == 8)) begin
                    uartlite0_uartrx0_state <= 2'b10;
                    uartlite0_uartrx0_bitcnt <= 0;
                end
            end
            2'b10: begin
                if (uartlite0_uartrx0_midbit) begin
                    uartlite0_uartrx0_state <= 2'b11;
                    uartlite0_uartrx0_fbusrx_write <= 1'b1;
                    uartlite0_uartrx0_fbusrx_write_data <= uartlite0_uartrx0_rxbyte;
                end
            end
            2'b11: begin
                uartlite0_uartrx0_state <= 2'b00;
                uartlite0_uartrx0_bitcnt <= 0;
            end
        endcase
    end
end


always @(posedge clock) begin: CATBOARD_UARTLITE0_UARTRX0_BEH_MID
    uartlite0_uartrx0_rxd <= uartlite0_rx;
    if (((uartlite0_uartrx0_rxd && (!uartlite0_rx)) && (uartlite0_uartrx0_state == 2'b00))) begin
        uartlite0_uartrx0_mcnt <= 0;
        uartlite0_uartrx0_rxinprog <= 1'b1;
    end
    else if ((uartlite0_uartrx0_rxinprog && (uartlite0_uartrx0_state == 2'b11))) begin
        uartlite0_uartrx0_rxinprog <= 1'b0;
    end
    else if (uartlite0_baudce16) begin
        uartlite0_uartrx0_mcnt <= (uartlite0_uartrx0_mcnt + 1);
    end
    if ((uartlite0_uartrx0_rxinprog && (uartlite0_uartrx0_mcnt == 7) && uartlite0_baudce16)) begin
        uartlite0_uartrx0_midbit <= 1'b1;
    end
    else begin
        uartlite0_uartrx0_midbit <= 1'b0;
    end
end


always @(posedge clock) begin: CATBOARD_UARTLITE0_UARTTX0_BEH_TX
    if (glbl_timer_ticks0_reset == 1) begin
        uartlite0_uarttx0_bitcnt <= 0;
        uartlite0_uarttx0_txbyte <= 0;
        uartlite0_uarttx0_state <= 3'b000;
        uartlite0_uarttx0_fbustx_read <= 0;
        uartlite0_tx <= 1;
    end
    else begin
        uartlite0_uarttx0_fbustx_read <= 1'b0;
        case (uartlite0_uarttx0_state)
            3'b000: begin
                if (((!uartlite0_uarttx0_fbustx_empty) && uartlite0_baudce)) begin
                    uartlite0_uarttx0_txbyte <= uartlite0_uarttx0_fbustx_read_data;
                    uartlite0_uarttx0_fbustx_read <= 1'b1;
                    uartlite0_uarttx0_state <= 3'b001;
                end
            end
            3'b001: begin
                if (uartlite0_baudce) begin
                    uartlite0_uarttx0_bitcnt <= 0;
                    uartlite0_tx <= 1'b0;
                    uartlite0_uarttx0_state <= 3'b010;
                end
            end
            3'b010: begin
                if (uartlite0_baudce) begin
                    uartlite0_uarttx0_bitcnt <= (uartlite0_uarttx0_bitcnt + 1);
                    uartlite0_tx <= uartlite0_uarttx0_txbyte[uartlite0_uarttx0_bitcnt];
                end
                else if ((uartlite0_uarttx0_bitcnt == 8)) begin
                    uartlite0_uarttx0_state <= 3'b011;
                    uartlite0_uarttx0_bitcnt <= 0;
                end
            end
            3'b011: begin
                if (uartlite0_baudce) begin
                    uartlite0_tx <= 1'b1;
                    uartlite0_uarttx0_state <= 3'b100;
                end
            end
            3'b100: begin
                if (uartlite0_baudce) begin
                    uartlite0_uarttx0_state <= 3'b000;
                end
            end
            default: begin
                if (1'b0 !== 1) begin
                    $display("*** AssertionError ***");
                end
            end
        endcase
    end
end



assign uartlite0_uarttx0_fbustx_read_data = uartlite0_fifo_fast0_mem[uartlite0_fifo_fast0_addr];


always @(posedge clock) begin: CATBOARD_UARTLITE0_FIFO_FAST0_BEH_OCCUPANCY
    if (glbl_timer_ticks0_reset == 1) begin
        uartlite0_fifo_fast0_nvacant <= 4;
        uartlite0_fifo_fast0_ntenant <= 0;
    end
    else begin
        if (uartlite0_fifo_fast0_fbus_clear) begin
            uartlite0_fifo_fast0_nvacant <= 4;
            uartlite0_fifo_fast0_ntenant <= 0;
        end
        else if ((uartlite0_uarttx0_fbustx_read && (!uartlite0_fbustx_write))) begin
            uartlite0_fifo_fast0_nvacant <= (uartlite0_fifo_fast0_nvacant + 1);
            uartlite0_fifo_fast0_ntenant <= (uartlite0_fifo_fast0_ntenant - 1);
        end
        else if ((uartlite0_fbustx_write && (!uartlite0_uarttx0_fbustx_read))) begin
            uartlite0_fifo_fast0_nvacant <= (uartlite0_fifo_fast0_nvacant - 1);
            uartlite0_fifo_fast0_ntenant <= (uartlite0_fifo_fast0_ntenant + 1);
        end
    end
end


always @(posedge clock) begin: CATBOARD_UARTLITE0_FIFO_FAST0_BEH_FIFO
    if (glbl_timer_ticks0_reset == 1) begin
        uartlite0_fbustx_full <= 0;
        uartlite0_uarttx0_fbustx_empty <= 1;
        uartlite0_fifo_fast0_addr <= 0;
    end
    else begin
        if (uartlite0_fifo_fast0_fbus_clear) begin
            uartlite0_fifo_fast0_addr <= 0;
            uartlite0_uarttx0_fbustx_empty <= 1'b1;
            uartlite0_fbustx_full <= 1'b0;
        end
        else if ((uartlite0_uarttx0_fbustx_read && (!uartlite0_fbustx_write))) begin
            uartlite0_fbustx_full <= 1'b0;
            if ((uartlite0_fifo_fast0_addr == 0)) begin
                uartlite0_uarttx0_fbustx_empty <= 1'b1;
            end
            else begin
                uartlite0_fifo_fast0_addr <= (uartlite0_fifo_fast0_addr - 1);
            end
        end
        else if ((uartlite0_fbustx_write && (!uartlite0_uarttx0_fbustx_read))) begin
            uartlite0_uarttx0_fbustx_empty <= 1'b0;
            if ((!uartlite0_uarttx0_fbustx_empty)) begin
                uartlite0_fifo_fast0_addr <= (uartlite0_fifo_fast0_addr + 1);
            end
            if (($signed({1'b0, uartlite0_fifo_fast0_addr}) == (4 - 2))) begin
                uartlite0_fbustx_full <= 1'b1;
            end
        end
    end
end


always @(posedge clock) begin: CATBOARD_UARTLITE0_FIFO_FAST0_BEH_SRL_IN
    integer jj;
    if (uartlite0_fbustx_write) begin
        uartlite0_fifo_fast0_mem[0] <= uartlite0_fbustx_write_data;
        for (jj=1; jj<4; jj=jj+1) begin
            uartlite0_fifo_fast0_mem[jj] <= uartlite0_fifo_fast0_mem[(jj - 1)];
        end
    end
end



assign uartlite0_fifo_fast0_fbus_read_valid = (uartlite0_uarttx0_fbustx_read && (!uartlite0_uarttx0_fbustx_empty));

// Map external UART FIFOBus interface to internal
// Map the external UART FIFOBus interface attribute signals to
// internal RX FIFO interface.

assign uartlite0_fbusrx_read = uartlite0_fifobus_read;
assign uartlite0_fifobus_empty = uartlite0_fbusrx_empty;
assign uartlite0_fifobus_read_data = uartlite0_fbusrx_read_data;
assign uartlite0_fifobus_read_valid = uartlite0_fbusrx_read_valid;



assign uart_tx = uartlite0_syncro1_staps[(3 - 1)];


always @(posedge clock) begin: CATBOARD_UARTLITE0_SYNCRO1_BEH_SYNC_STAGES
    integer ii;
    uartlite0_syncro1_staps[0] <= uartlite0_tx;
    for (ii=1; ii<3; ii=ii+1) begin
        uartlite0_syncro1_staps[ii] <= uartlite0_syncro1_staps[(ii - 1)];
    end
end



assign uartlite0_fbusrx_read_data = uartlite0_fifo_fast1_mem[uartlite0_fifo_fast1_addr];


always @(posedge clock) begin: CATBOARD_UARTLITE0_FIFO_FAST1_BEH_OCCUPANCY
    if (glbl_timer_ticks0_reset == 1) begin
        uartlite0_fifo_fast1_nvacant <= 4;
        uartlite0_fifo_fast1_ntenant <= 0;
    end
    else begin
        if (uartlite0_fifo_fast1_fbus_clear) begin
            uartlite0_fifo_fast1_nvacant <= 4;
            uartlite0_fifo_fast1_ntenant <= 0;
        end
        else if ((uartlite0_fbusrx_read && (!uartlite0_uartrx0_fbusrx_write))) begin
            uartlite0_fifo_fast1_nvacant <= (uartlite0_fifo_fast1_nvacant + 1);
            uartlite0_fifo_fast1_ntenant <= (uartlite0_fifo_fast1_ntenant - 1);
        end
        else if ((uartlite0_uartrx0_fbusrx_write && (!uartlite0_fbusrx_read))) begin
            uartlite0_fifo_fast1_nvacant <= (uartlite0_fifo_fast1_nvacant - 1);
            uartlite0_fifo_fast1_ntenant <= (uartlite0_fifo_fast1_ntenant + 1);
        end
    end
end


always @(posedge clock) begin: CATBOARD_UARTLITE0_FIFO_FAST1_BEH_FIFO
    if (glbl_timer_ticks0_reset == 1) begin
        uartlite0_fifo_fast1_fbus_full <= 0;
        uartlite0_fbusrx_empty <= 1;
        uartlite0_fifo_fast1_addr <= 0;
    end
    else begin
        if (uartlite0_fifo_fast1_fbus_clear) begin
            uartlite0_fifo_fast1_addr <= 0;
            uartlite0_fbusrx_empty <= 1'b1;
            uartlite0_fifo_fast1_fbus_full <= 1'b0;
        end
        else if ((uartlite0_fbusrx_read && (!uartlite0_uartrx0_fbusrx_write))) begin
            uartlite0_fifo_fast1_fbus_full <= 1'b0;
            if ((uartlite0_fifo_fast1_addr == 0)) begin
                uartlite0_fbusrx_empty <= 1'b1;
            end
            else begin
                uartlite0_fifo_fast1_addr <= (uartlite0_fifo_fast1_addr - 1);
            end
        end
        else if ((uartlite0_uartrx0_fbusrx_write && (!uartlite0_fbusrx_read))) begin
            uartlite0_fbusrx_empty <= 1'b0;
            if ((!uartlite0_fbusrx_empty)) begin
                uartlite0_fifo_fast1_addr <= (uartlite0_fifo_fast1_addr + 1);
            end
            if (($signed({1'b0, uartlite0_fifo_fast1_addr}) == (4 - 2))) begin
                uartlite0_fifo_fast1_fbus_full <= 1'b1;
            end
        end
    end
end


always @(posedge clock) begin: CATBOARD_UARTLITE0_FIFO_FAST1_BEH_SRL_IN
    integer jj;
    if (uartlite0_uartrx0_fbusrx_write) begin
        uartlite0_fifo_fast1_mem[0] <= uartlite0_uartrx0_fbusrx_write_data;
        for (jj=1; jj<4; jj=jj+1) begin
            uartlite0_fifo_fast1_mem[jj] <= uartlite0_fifo_fast1_mem[(jj - 1)];
        end
    end
end



assign uartlite0_fbusrx_read_valid = (uartlite0_fbusrx_read && (!uartlite0_fbusrx_empty));

// Map external UART FIFOBus interface to internal
// Map external UART FIFOBus interface attribute signals to
// internal TX FIFO interface.

assign uartlite0_fbustx_write = (uartlite0_fifobus_write & (!uartlite0_fbustx_full));
assign uartlite0_fbustx_write_data = uartlite0_fifobus_write_data;
assign uartlite0_fifobus_full = uartlite0_fbustx_full;


always @(command_bridge0_ready, uartlite0_fifobus_empty) begin: CATBOARD_COMMAND_BRIDGE0_BEH_FIFO_READ
    if ((command_bridge0_ready && (!uartlite0_fifobus_empty))) begin
        uartlite0_fifobus_read = 1'b1;
    end
    else begin
        uartlite0_fifobus_read = 1'b0;
    end
end


always @(posedge clock) begin: CATBOARD_COMMAND_BRIDGE0_CONTROLLER_BASIC0_BEH_SM
    if (glbl_timer_ticks0_reset == 1) begin
        command_bridge0_controller_basic0_tocnt <= 0;
        command_bridge0_controller_basic0_state <= 3'b000;
    end
    else begin
        case (command_bridge0_controller_basic0_state)
            3'b000: begin
                if ((!memmap_done)) begin
                    command_bridge0_controller_basic0_state <= 3'b001;
                end
                else if (memmap_write) begin
                    command_bridge0_controller_basic0_state <= 3'b010;
                end
                else if (memmap_read) begin
                    command_bridge0_controller_basic0_state <= 3'b100;
                end
            end
            3'b001: begin
                if (memmap_done) begin
                    command_bridge0_controller_basic0_tocnt <= 0;
                    if (memmap_write) begin
                        command_bridge0_controller_basic0_state <= 3'b110;
                    end
                    else if (memmap_read) begin
                        command_bridge0_controller_basic0_state <= 3'b101;
                    end
                end
            end
            3'b010: begin
                command_bridge0_controller_basic0_state <= 3'b110;
                command_bridge0_controller_basic0_tocnt <= 0;
            end
            3'b100: begin
                command_bridge0_controller_basic0_state <= 3'b101;
            end
            3'b101: begin
                if (memmap_done) begin
                    command_bridge0_controller_basic0_state <= 3'b110;
                end
            end
            3'b110: begin
                if ((!(memmap_write || memmap_read))) begin
                    command_bridge0_controller_basic0_state <= 3'b000;
                end
            end
            default: begin
                if (1'b0 !== 1) begin
                    $display("*** AssertionError ***");
                end
            end
        endcase
    end
end


always @(posedge clock) begin: CATBOARD_COMMAND_BRIDGE0_BEH_STATE_MACHINE
    integer ii;
    reg [8-1:0] bytecnt;
    integer val;
    integer idx;
    if (glbl_timer_ticks0_reset == 1) begin
        uartlite0_fifobus_write <= 0;
        memmap_read <= 0;
        memmap_write <= 0;
        command_bridge0_bytemon <= 0;
        memmap_mem_addr <= 0;
        memmap_write_data <= 0;
        command_bridge0_packet[0] <= 0;
        command_bridge0_packet[1] <= 0;
        command_bridge0_packet[2] <= 0;
        command_bridge0_packet[3] <= 0;
        command_bridge0_packet[4] <= 0;
        command_bridge0_packet[5] <= 0;
        command_bridge0_packet[6] <= 0;
        command_bridge0_packet[7] <= 0;
        command_bridge0_packet[8] <= 0;
        command_bridge0_packet[9] <= 0;
        command_bridge0_packet[10] <= 0;
        command_bridge0_packet[11] <= 0;
        command_bridge0_state <= 4'b0000;
        command_bridge0_error <= 0;
        command_bridge0_ready <= 0;
        uartlite0_fifobus_write_data <= 0;
        command_bridge0_bb_per_addr <= 0;
        bytecnt = 0;
    end
    else begin
        case (command_bridge0_state)
            4'b0000: begin
                command_bridge0_state <= 4'b0001;
                command_bridge0_ready <= 1'b1;
                bytecnt = 0;
            end
            4'b0001: begin
                if (uartlite0_fifobus_read_valid) begin
                    for (ii=0; ii<2; ii=ii+1) begin
                        case (ii)
                            0: idx = 0;
                            default: idx = 7;
                        endcase
                        case (ii)
                            0: val = 222;
                            default: val = 202;
                        endcase
                        if (($signed({1'b0, bytecnt}) == idx)) begin
                            if (($signed({1'b0, uartlite0_fifobus_read_data}) != val)) begin
                                command_bridge0_error <= 1'b1;
                                command_bridge0_state <= 4'b1001;
                            end
                        end
                    end
                    command_bridge0_packet[bytecnt] <= uartlite0_fifobus_read_data;
                    bytecnt = (bytecnt + 1);
                end
                if ((bytecnt == 12)) begin
                    command_bridge0_ready <= 1'b0;
                    command_bridge0_state <= 4'b0010;
                end
            end
            4'b0010: begin
                command_bridge0_bb_per_addr <= command_bridge0_address[32-1:28];
                memmap_mem_addr <= command_bridge0_address[28-1:0];
                if (memmap_done !== 1) begin
                    $display("*** AssertionError ***");
                end
                bytecnt = 0;
                case (command_bridge0_packet[1])
                    'h1: begin
                        command_bridge0_state <= 4'b0101;
                    end
                    'h2: begin
                        memmap_write_data <= command_bridge0_data;
                        command_bridge0_state <= 4'b0011;
                    end
                    default: begin
                        command_bridge0_error <= 1'b1;
                        command_bridge0_state <= 4'b1001;
                    end
                endcase
            end
            4'b0011: begin
                if (memmap_done) begin
                    memmap_write <= 1'b1;
                    command_bridge0_state <= 4'b0100;
                end
            end
            4'b0100: begin
                memmap_write <= 1'b0;
                if (memmap_done) begin
                    command_bridge0_state <= 4'b0101;
                end
            end
            4'b0101: begin
                if (memmap_done) begin
                    memmap_read <= 1'b1;
                    command_bridge0_state <= 4'b0110;
                end
            end
            4'b0110: begin
                memmap_read <= 1'b0;
                if (memmap_done) begin
                    command_bridge0_packet[(8 + 0)] <= memmap_read_data[32-1:24];
                    command_bridge0_packet[(8 + 1)] <= memmap_read_data[24-1:16];
                    command_bridge0_packet[(8 + 2)] <= memmap_read_data[16-1:8];
                    command_bridge0_packet[(8 + 3)] <= memmap_read_data[8-1:0];
                    command_bridge0_state <= 4'b0111;
                end
            end
            4'b0111: begin
                uartlite0_fifobus_write <= 1'b0;
                if ((bytecnt < 12)) begin
                    if ((!uartlite0_fifobus_full)) begin
                        uartlite0_fifobus_write <= 1'b1;
                        uartlite0_fifobus_write_data <= command_bridge0_packet[bytecnt];
                        bytecnt = (bytecnt + 1);
                    end
                    command_bridge0_state <= 4'b1000;
                end
                else begin
                    command_bridge0_state <= 4'b1010;
                end
            end
            4'b1000: begin
                uartlite0_fifobus_write <= 1'b0;
                command_bridge0_state <= 4'b0111;
            end
            4'b1001: begin
                if ((!uartlite0_fifobus_read_valid)) begin
                    command_bridge0_state <= 4'b1010;
                    command_bridge0_ready <= 1'b0;
                end
            end
            4'b1010: begin
                command_bridge0_error <= 1'b0;
                command_bridge0_ready <= 1'b0;
                command_bridge0_state <= 4'b0000;
            end
            default: begin
                if (1'b0 !== 1) begin
                    $display("*** AssertionError ***");
                end
            end
        endcase
        command_bridge0_bytemon <= bytecnt;
    end
end


always @(posedge clock) begin: CATBOARD_BEH_LED_CONTROL
    memmap_done <= (!(memmap_write || memmap_read));
    if ((memmap_write && (memmap_mem_addr == 32))) begin
        ledreg <= memmap_write_data;
    end
end


always @(memmap_read, memmap_mem_addr, ledreg) begin: CATBOARD_BEH_LED_READ
    if ((memmap_read && (memmap_mem_addr == 32))) begin
        memmap_read_data = ledreg;
    end
    else begin
        memmap_read_data = 0;
    end
end


always @(posedge clock) begin: CATBOARD_BEH_ASSIGN
    if (glbl_tick_sec) begin
        tone <= ((~tone) & 1);
    end
    led <= (ledreg | tone[5-1:0]);
end

endmodule
